#lang racket
(require (planet dyoo/while-loop:1:=1))
(require "etc.rkt")
(require "read.rkt")
(provide write/comments)
(define (write/comments xs)
 (define (abbrev-prefix x)
  (and (list? x)
       (= (length x) 2)
       (case (car x)
        ((quasiquote)
         "`")
        ((quote)
         "'")
        ((unquote)
         ",")
        ((unquote-splicing)
         ",@")
        (else
         #f))))

 (define (args xs col)
  (when (car? blank-symbol xs)
   (set! xs (cdr xs)))
  (for ((x xs)) (newline)
   (unless (eq? blank-symbol x)
    (indent col))
   (block x col))
  (display ")"))

 (define (bindings xs col)
  (when (car? blank-symbol xs)
   (set! xs (cdr xs)))
  (for* x xs xs
   (if (atom? x)
    (write x)
    (begin
     (display "(")
     (inline (car x))
     (display " ")
     (block (cadr x) (+ col 1 (width (car x)) 1))
     (display ")")))
   (when (pair? (cdr xs))
    (newline)
    (indent col)))
  (display ")"))

 (define (block x col)
  (cond
   ((eq? blank-symbol x)#f)
   ((not (list? x))
    (inline x))
   ((null? x)
    (inline x))
   ((car? comment-symbol x)
    (display (cadr x)))
   ((and (abbrev-prefix x)
         (list? (cadr x))
         (andmap atom? (cadr x)))
    (inline x))
   ((abbrev-prefix x)
    (display (abbrev-prefix x))
    (block (cadr x) (+ col (string-length (abbrev-prefix x)))))

   ; 0 special args
   ((memq (car x) '(begin collect))
    (display "(")
    (write (car x))
    (args (cdr x) (add1 col)))
   ((memq (car x) '(cond))
    (display "(")
    (write (car x))
    (clauses (cdr x) (add1 col)))

   ; 1 special arg
   ((and (length? 2 x)
         (memq (car x) '(case match syntax-rules)))
    (display "(")
    (inline (car x))
    (display " ")
    (block (cadr x) (+ col 1 (width (car x)) 1))
    (clauses (cddr x) (add1 col)))
   ((and (length? 2 x)
         (or (defun? x)
             (memq (car x)
                   (quote
                          (define-record-printer define-record-type
                           define-syntax
                           defstruct
                           lambda
                           receive)))))
    (display "(")
    (write (car x))
    (display " ")
    (inline (cadr x))
    (args (cddr x) (add1 col)))
   ((and (length? 2 x)
         (memq (car x) '(do-until do-while if unless when)))
    (display "(")
    (write (car x))
    (display " ")
    (block (cadr x) (+ col 1 (width (car x)) 1))
    (args (cddr x) (add1 col)))

   ; 2 special args
   ((and
     (length? 3 x)
     (memq (car x)
           '(any-rec? do-list do-times filt for map-rec module transform)))
    (display "(")
    (write (car x))
    (display " ")
    (write (cadr x))
    (display " ")
    (inline (caddr x))
    (args (cdddr x) (add1 col)))

   ; 3 special args
   ((and (length? 4 x)
         (memq (car x) '(for*)))
    (display "(")
    (write (car x))
    (display " ")
    (write (cadr x))
    (display " ")
    (write (caddr x))
    (display " ")
    (inline (cadddr x))
    (args (cddddr x) (add1 col)))

   ; Let
   ((and (length? 3 x)
         (memq (car x) '(let let* letrec letrec*))
         (list? (cadr x)))
    (display "(")
    (write (car x))
    (display " (")
    (bindings (cadr x) (+ col 1 (width (car x)) 2))
    (args (cddr x) (add1 col)))
   ((and (length? 3 x)
         (memq (car x) '(let)))
    (display "(")
    (write (car x))
    (display " ")
    (write (cadr x))
    (display " (")
    (bindings (caddr x) (+ col 1 (width (car x)) 1 (width (cadr x)) 2))
    (args (cdddr x) (add1 col)))

   ; Args inline
   ((and (not (memq (car x) '(and or)))
         (andmap inline? x)
         (< (+ col 1 (length x) (apply + (map width x))) 80))
    (inline x))

   ; Args aligned with first
   ((and (length? 2 x)
         (inline? (car x))
         (andmap (lambda (y)
                  (< (+ col 1 (width (car x)) 1 (width y)) 80))
                 (cdr x))
         (cdr x))
    (display "(")
    (inline (car x))
    (display " ")
    (inc! col (+ 1 (width (car x)) 1))
    (block (cadr x) col)
    (args (cddr x) col))

   ; First arg inline anyway
   ((and (length? 2 x)
         (memq (car x) '(define set!)))
    (display "(")
    (inc! col)
    (inline (car x))
    (display " ")
    (inline (cadr x))
    (args (cddr x) col))

   ; Args unaligned
   (else
    (display "(")
    (inc! col)
    (block (car x) col)
    (args (cdr x) col))))

 (define (clauses xs col)
  (when (car? blank-symbol xs)
   (set! xs (cdr xs)))
  (for ((clause xs)) (newline)
   (cond
    ((eq? blank-symbol clause))
    ((car? comment-symbol clause)
     (indent col)
     (display (cadr clause)))
    ((atom? clause)
     (indent col)
     (write clause))
    ((improper-list? clause)
     (indent col)
     (inline clause))
    (else
     (indent col)
     (display "(")
     (block (car clause) (add1 col))
     (args (cdr clause) (add1 col)))))
  (display ")"))

 (define (inline x)
  (cond
   ((abbrev-prefix x)
    (display (abbrev-prefix x))
    (inline (cadr x)))
   ((list? x)
    (display "(")
    (while (pair? x)
           (inline (car x))
           (set! x (cdr x))
           (when (pair? x)
            (display " ")))
    (display ")"))
   ((pair? x)
    (display "(")
    (while (pair? x)
           (inline (car x))
           (set! x (cdr x))
           (if (pair? x)
            (display " ")
            (unless (null? x)
             (display " . ")
             (inline x))))
    (display ")"))
   (else
    (write x))))

 (define (inline? x)
  (and (not (any-rec? y x
             (eq? y blank-symbol)))
       (not (any-rec? y x
             (eq? y comment-symbol)))
       (not (string-contains? (with-output-to-string (lambda ()
                                                      (block x 0)))
                              "\n"))))

 (define (max-line-width s)
  (if (string=? s "")
   0
   (apply max (map string-length (string-split s "\n")))))

 (define (width x)
  (or (hash-ref widths x #f))
  (let ((w (max-line-width (with-output-to-string (lambda ()
                                                   (block x 0))))))
   (hash-set! widths x w)
   w))

 (when (eq? (car xs) '|#lang|)
  (display (car xs))
  (display " ")
  (display (cadr xs))
  (newline)
  (set! xs (cddr xs)))
 (for ((x xs)) (block x 0)
  (newline)))

(define widths (make-hash))
